<!doctype html>
<!--[if IE 6]>
<html id="ie6" lang="zh-CN">
<![endif]-->
<!--[if IE 7]>
<html id="ie7" lang="zh-CN">
<![endif]-->
<!--[if IE 8]>
<html id="ie8" lang="zh-CN">
<![endif]-->
<!--[if !(IE 6) | !(IE 7) | !(IE 8)  ]><!-->
<html lang="zh-CN">
 <!--<![endif]-->
 <head>      
  <link rel="stylesheet" type="text/css" media="all" href="stylesheets/style.css">     
  <link rel="stylesheet" id="codebox-css" href="stylesheets/codebox.css" type="text/css" media="screen">             
 </head> 
 <body class="single single-post postid-213 single-format-standard content-sidebar"> 
  <div id="page" class="hfeed"> 
   <header id="branding" role="banner"> 
    <hgroup> 
     <h1 id="site-title"><span><a href="http://codelifeliwan.github.io/" title="Code_Life_LiWan" rel="home">Code_Life_LiWan</a></span></h1> 
     <h2 id="site-description">My heart will go on and on…</h2> 
    </hgroup>  
    <!-- #access --> 
   </header>
   <!-- #branding --> 
   <div id="main" class="clearfix"> 
    <div id="primary"> 
     <div id="content" role="main"> 
      <!-- #nav-single --> 
      <article id="post-213" class="post-213 post type-post status-publish format-standard hentry category-professional_exchanges tag-nasm"> 
       <header class="entry-header"> 
        <h1 class="entry-title">nasm</h1> 
        <div class="entry-meta"> 
         <span class="sep">Posted on </span>
         <a href="http://codelifeliwan.github.io/?p=213" title="下午 8:41" rel="bookmark"><time class="entry-date" datetime="2011-12-05T20:41:21+00:00" pubdate>5 十二月, 2011</time></a>
         <span class="by-author"> <span class="sep"> by </span> <span class="author vcard"><a class="url fn n" href="http://codelifeliwan.github.io/?author=1" title="View all posts by wanli" rel="author">wanli</a></span></span> 
         <span class="sep"> — </span> 
         <span class="comments-link"> <a href="http://codelifeliwan.github.io/?p=213#respond" title="Comment on nasm">No Comments ↓</a> </span> 
        </div>
        <!-- .entry-meta --> 
       </header>
       <!-- .entry-header --> 
       <div class="entry-content">
        <div class="entry-content"> 
         <p> 段寄存器存放 基地址</p> 
         <p>&nbsp;<wbr></p> 
         <p>AX&nbsp;<wbr> 通用寄存器</p> 
         <p>CS 存放要被cpu执行的代码的基地址 code segment<br> IP 别名为指令指针寄存器，存放段地址的偏移地址<br> CS*16+IP&nbsp;<wbr> 就是cpu要执行的指令</p> 
         <p> debug是dos、windows都提供的实模式程序调试工具，可以查看cpu各种寄存器中的内容和机器码级跟踪程序的运行</p> 
         <p>r命令用来查看和改变各个寄存器内容，<br> d命令查看内存中的内容，<br> u命令将内存机器码转为汇编指令，<br> a命令以汇编指令格式在内存写入指令<br> t命令但不跟踪</p> 
         <p> 数据段：全局变量<br> 代码段：代码<br> 堆栈段：局部变量</p> 
         <p>CPU根据DS(Data Segment)这个寄存器和任意一个通用寄存器的值或其他数值组成数据段的物理地址如：<br> DS:[0] DS:[BX]&nbsp;<wbr> (内存寻址)&nbsp;<wbr><br> (内存访问)</p> 
         <p>mov<br> ds:[13ABH],1234H&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 内存地址的内容进行赋值&nbsp;<wbr> 内存地址=1234<br> mov<br> [13ABH],1234H&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> CPU默认指向ds</p> 
         <p> ———————4—————————–</p> 
         <p>CPU如何知道一段内存空间被当作栈使用？执行入栈出栈时，如何知道哪个单元式栈顶单元？<br> cpu通过ss这个寄存器和sp通用寄存器来感知堆栈段的存在。<br> ss存放基地址，sp存放栈顶的偏移地址，任何时候ss:sp都指向栈顶元素</p> 
         <p>———————5，6—————————–</p> 
         <p>汇编语言中变量如何定义<br> 如何屏幕显示<br> 如何进行调试</p> 
         <p>assume关键字<br> 如何让汇编语言“知道”，我们编写的应用程序有多少个段组成。<br> assume表示用来假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联</p> 
         <p>db指令<br> define byte<br> label db initializer,initializer,initializer<br> label 表示任选标号，相当于c语言变量名<br> msg db “hello world”</p> 
         <p>vga B800F<br> &nbsp;<wbr> 字体属性格式<br> 7&nbsp;<wbr> 6 5 4 3 2 1 0<br> BL R G B I R G B</p> 
         <p>闪烁 背景色 高亮 前景色<br> 红底绿字: 01000010B</p> 
         <p>vga显存地址空间<br> 在80*25列彩色模式下显示器可以显示25行80列<br> 每个字符可以有256种属性(背景色前景色闪烁等)<br> 一个字符在显存中占两个字节，分别存放ascii码值和属性<br> 显示缓冲总共分为8页，每页4kb，显卡可以显示任意页内容一般情况下显示第0页内容即B8000H~B8F9FH</p> 
         <p>es,扩展段寄存器</p> 
         <p>不能直接给段寄存器赋值，应该先给通用寄存器赋值，然后再传给段寄存器</p> 
         <p>loop关键字<br> 语法：<br> 标号：&nbsp;<wbr> 指令<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 指令2<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> look 标号<br> cx内部规定为loop的循环因子</p> 
         <p>内存访问<br> helloworld属于数据段内容，那么其中每个字符都可以通过数据段地址存在ds寄存器中，那么要获得数据段第一个字节内容就要如下表示</p> 
         <p>ds:[0] ds:[si]<br> si寄存器相当于通用寄存器</p> 
         <p>代码段地址自动获取 偏移地址不知道</p> 
         <p> ;;;;;;;;;;;;;;;;;;;;;hello.asm;;;;;;;;;;;;;;;;;;;;;;;;;;;;</p> 
         <p>assume cs:code,ds:data</p> 
         <p>data segment<br> &nbsp;<wbr> db “hello world”<br> data ends</p> 
         <p>code segment<br> &nbsp;<wbr> start:<br> &nbsp;<wbr> mov ax,data<br> &nbsp;<wbr> mov ds,ax<br> &nbsp;<wbr> mov bx,0b800h<br> &nbsp;<wbr> mov es,bx<br> &nbsp;<wbr> mov cx,11<br> &nbsp;<wbr> mov si,0<br> &nbsp;<wbr> mov bx,0<br> &nbsp;<wbr> mov ah,01000010b<br> &nbsp;<wbr> s:mov al,ds:[si]<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> mov es:[bx],ax<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> mov es:[bx+1],ah<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> inc si<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> add bx,2<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> loop s<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
         <p>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> mov ax,4c00h<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> int 21h<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
         <p>code ends<br> end start</p> 
         <p>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</p> 
         <p> ——————-7—————————–</p> 
         <p>什么是中断？<br> 任何一个通用CPU，都具有一种能力，可以在执行完成当前正在执行的指令之后，检测到从CPU外部或内部产生的一种特殊信息，<br> 并立即对接受的信息进程处理。这种信息称之为中断信息。<br> 中断的意思是指，CPU不再接着（刚执行完的指令）向下执行，而是转去处理这个特殊信息。</p> 
         <p>关于中断的疑问<br> 中断发生时CPU如何找到中断处理程序？<br> 中断处理程序有很多种，那么每个中断处理程序放在哪里？<br> 中断处理程序完成后CPU如何继续运行之前被中断的程序？</p> 
         <p>中断向量表<br> 在内存中保存，其中存放着256个中断源所对应的中断处理程序入口<br> 中断向量表一般都保存在内存0000:0000到0000:03FE</p> 
         <p>一个表项存放一个中断向量，也就是一个中断程序入口地址，这个地址包括段地址和偏移地址，每个表占两个字（4个字节），高地址存放段地址，低地址存放偏移地址。</p> 
         <p>遇到中断时CPU把cs和ip内存入栈暂时保存起来。等中断程序执行结束后通过出栈指令重新获得原来的cs和ip的值（这就是c语言函数调用具体实现）</p> 
         <p>中断过程这些操作，cpu自动完成</p> 
         <p>div指令<br> 除法指令：div 寄存器<br> 除数：有8位和16位两种，在一个寄存器或内存单元中。<br> 被除数：默认放在ax或dx中，如果除数为8位，被除数位16位默认放在ax中。如果除数为16位被除数为32位分别放在ax和dx中，dx存放高位，ax存放地位。</p> 
         <p>结果：如果除数位8位，则al存储除法的商，ah存储除法的余数，如果除数是16位，则ax存储商，dx存储余数。</p> 
         <p>修改中断表：<br> 如何让CPU不去执行原来的中断处理程序，而去执行我们自己编写的处理程序？<br> 修改中断向量表的入口地址就可以实现。</p> 
         <p> ——————-8———————-<br> 如何修改中断向量表？<br> 系统默认在0000:0000到0000:03FE专门存放中断向量表。并且每个表占用两个字。<br> 那么我们就知道0号中断表项所在的内存地址是0000:0000开始的4个字节中。汇编代码就是要对这4个字节赋予我们自己编写的中断处理程序入口地址。</p> 
         <p>汇编伪代码如下：<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov<br> ds:[0],我们自己中断处理程序偏移地址<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov<br> ds:[2],我们自己中断处理程序段地址</p> 
         <p>中断随时都可以产生，那么当中断产生时必须马上执行中断处理程序，那么中断处理程序必须放在内存何处？<br> 要保证任何时候中断处理程序存放位置不能被其他程序覆盖。<br> 因此我们必须在内存中找出一段空间是任何程序不适用的。<br> 在正常情况下内存地址0000:0200到0000:0300这段内存是没有其他程序使用的。</p> 
         <p>中断处理程序内存分布<br> 当中断被触发时程序将被执行，但是程序最开始是数据定义指令，而不是代码执行指令，如何解决？<br> 我们希望一开始执行中断处理程序时马上跳转到显示字符串的汇编代码中执行，这时我们就需要使用汇编指令：jump</p> 
         <p>跳转指令jump分为三种：<br> 段间跳转 jump far<br> 标号&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 把cs和ip寄存器的值变为标号所在的内存地址<br> 段内跳转指令 jump near<br> 标号&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 只修改ip寄存器值为标号的偏移地址<br> 段内短跳转指令 jump short<br> 标号&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 不修改cs和ip的值，编译器自动计算跳转的位置，不超过256</p> 
         <p> ——————-9————————–<br> 如何把一段汇编代码拷贝到指定的内存位置？<br> 可以用loop指令语句来实现，但是该语句比较繁琐，不太合适。<br> 汇编语言提供rep和movsb指令实现相同的功能。<br> movsb指令：<br> 字节传送指令：指令在存储单元之间传送字符串<br> 使用movsb指令时ds:si指向了要拷贝字符串的首地址，es:di指向了要拷贝的目的地址。<br> cld指令拷贝数据的方向是从低字节往高字节拷贝，也就是说每拷贝一个字节si和di加1。<br> std指令和cld相反。</p> 
         <p>;;;;;;;;;;;;;;;;;;;;;;;;;;ins.asm;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</p> 
         <p>assume cs:code</p> 
         <p>code segment<br> &nbsp;<wbr><br> ;第一步：把中断向量表中0号表项内容进行修改，使之指向我们自己编写的中断处理程序的入口地址<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> start:<br> &nbsp;<wbr> mov ax,0<br> &nbsp;<wbr> mov ds,ax<br> &nbsp;<wbr> mov word ptr ds:[0],0200h<br> &nbsp;<wbr> mov word ptr ds:[2],0<br> &nbsp;<wbr><br> ;第三步：把我们刚才编写好的0号中断处理程序拷贝到中断向量表中0号表项所指向的内存地址中<br> &nbsp;<wbr> ;0000:0200<br> &nbsp;<wbr> mov ax,cs<br> &nbsp;<wbr> mov ds,ax<br> &nbsp;<wbr> mov si,offset int0;ds:si 可得拷贝源地址<br> &nbsp;<wbr> mov ax,0<br> &nbsp;<wbr> mov es,ax<br> &nbsp;<wbr> mov di,200h;目的地址设置完毕es:di<br> &nbsp;<wbr> mov cx,offset int0end – offset<br> int0;计算出程序总共占多少内存<br> &nbsp;<wbr> cld<br> &nbsp;<wbr> rep movsb;自动利用es:di,ds:si,cx<br> &nbsp;<wbr> ;第四步：利用代码自动引发0号中断处理程序<br> &nbsp;<wbr> mov ax,1000h<br> &nbsp;<wbr> mov bh,1<br> &nbsp;<wbr> div bh<br> &nbsp;<wbr><br> &nbsp;<wbr> mov ax,4c00h<br> &nbsp;<wbr> int 21h<br> &nbsp;<wbr>&nbsp;<wbr><br> &nbsp;<wbr><br> &nbsp;<wbr> ;第二步：编写自己的中断处理程序，实现在屏幕中央显示字符串的功能<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> int0:jmp<br> short int0start<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db “i am student”<br> &nbsp;<wbr> int0start:mov ax,0b800h<br> &nbsp;<wbr> mov es,ax&nbsp;<wbr> ;配置显存首地址<br> &nbsp;<wbr> ;要把字符串一个个拷贝到显存地址空间中<br> &nbsp;<wbr> mov ax,cs<br> &nbsp;<wbr> mov ds,ax<br> &nbsp;<wbr><br> &nbsp;<wbr> mov si,202h<br> &nbsp;<wbr> mov di,12*160+36*2<br> &nbsp;<wbr> mov cx,12<br> &nbsp;<wbr> s:mov al,ds:[si]<br> &nbsp;<wbr> mov es:[di],al<br> &nbsp;<wbr> inc si<br> &nbsp;<wbr> add di,2<br> &nbsp;<wbr> loop s<br> &nbsp;<wbr><br> &nbsp;<wbr> mov ax,4c00h<br> &nbsp;<wbr> int 21h<br> &nbsp;<wbr> int0end:nop<br> &nbsp;<wbr><br> code ends<br> end start</p> 
         <p>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</p> 
         <p>——————-10————————–<br> 主要内容<br> 开发环境搭建<br> 认识引导程序<br> nasm汇编<br> 编写第一个启动程序</p> 
         <p>Visual PC2004 用来启动我们编写的启动程序<br> VMware运行linux，利用nasm汇编器在linux上进行启动程序的编译工作</p> 
         <p>知识预备<br> 理解计算机加电过程<br> BIOS对系统内存的分配<br> 认识引导程序的概念<br> 使用nasm进行编译<br> 制作软盘镜像</p> 
         <p>当我们按下电源按钮后，计算机是如何从无到有将操作系统运行起来的？<br> 按下开机按钮后，将发送电信号给BIOS。<br> BIOS获得电信号后将启动自检查程序，检查周边设备是否通电完毕。<br> 检查完毕后自检程序把控制权交还给BIOS，BIOS将读取引导驱动器中的启动程序。</p> 
         <p>在系统加电时，最初的1MB内存是BIOS为我们准备好的，如下：<br> 0x00000~0x003FF&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 中断向量表<br> 0x00400~0x004FF&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> BIOS数据区<br> 0x00500~0x07BFF&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 自由内存区<br> 0x07C00~0x07DFF&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 引导程序加载区&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 正好512字节<br> ox07E00~0x9FFFF&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 自由内存区<br> 0xA0000~0xBFFFF&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 显示内存区<br> 0xC0000~0xFFFFF&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 中断处理程序</p> 
         <p>认识引导程序<br> 什么样程序才能称为引导程序？<br> BIOS将所检查启动磁盘的第一个扇区512字节载入内存，放于内存0x0000:0x07c00处。<br> 如果第一扇区最后两个字节是AA55，那么它就是一个引导程序。</p> 
         <p>引导程序特点<br> 大小是512字节，不能多也不能少，因为BIOS只读取512B到内存中。<br> 它结尾必须是55AA，这是引导扇区标志。<br> 它总是放在磁盘第一个扇区上（0磁头0此道1扇区）因为BIOS只读取第一个扇区。</p> 
         <p>NASM汇编<br> 是一个为可移植性与模块化而设计的一个80*86的汇编器。它支持相当多的目标文件格式包括linux和windows</p> 
         <p>引导程序编写<br> 如何使用nasm编写一个引导程序？<br> 什么是nasm，它和masm有什么区别？<br> 如何在linux下安装nasm？<br> 如何用nasm编译自己编写的汇编代码？</p> 
         <p>nasm和masm区别<br> nasm拥有一个相当简单的内存引用规则，是任何对内存中内容的存取操作必须要在地址上加方括号。但任何地址值的操作不需要。<br> 比如mov ax,bar的指令表示把bar的地址赋给ax寄存器，这相当于masm中 mov ax,offset bar。<br> 要获得bar变量的值则：mov ax,[bar]。<br> masm mov<br> ax,es:di&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> nasm&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov<br> ax,[es:di]</p> 
         <p>linux 下安装nasm，下载nasm的rpm包，安装 rpm -ivh nasm***.rpm<br> 使用：nasm hello.asm -o hello ,反汇编：ndisasm hello</p> 
         <p> ——————-11—————————–</p> 
         <p>BIOS中断程序<br> 系统BIOS为我们提供了众多的中断处理程序给我们调用，其中中断编号为10h的中断处理程序专门实现显示功能。<br> 特别注意：编号为10h的中断并不只提供一个程序，而是提供了很多子程序供我们调用。</p> 
         <p>$和$$关键字<br> 在nasm中$表示当前指令的偏移地址<br> 在nasm中$$表示指令所在的开始地址<br> 因此我们就可以推算出剩余字节数公式<br> 剩余字节数=510-($-$$)</p> 
         <p>;;;;;;;;;;;;boot.asm;;;;;;;;;;;;;;;;</p> 
         <p>;我们的启动程序实现很简单的功能，在屏幕中央打印一行字符串即可</p> 
         <p>org 07c00h ;org指令明确告诉编译器我程序的段地址是7C00h，而不是原来的0000<br> ;int汇编指令 “int 10h”调用bois里的中断程序：显示字符串</p> 
         <p>&nbsp;<wbr> mov ax,cs<br> &nbsp;<wbr> mov es,ax<br> &nbsp;<wbr> mov bp,msgstr&nbsp;<wbr> ;es:bp<br> 指向的内容就是我们要显示的字符串地址了<br> &nbsp;<wbr><br> &nbsp;<wbr> mov<br> cx,12&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;显示的字符串长度<br> &nbsp;<wbr> mov<br> dh,12&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;显示的行号<br> &nbsp;<wbr> mov<br> dl,36&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;显示的列号<br> &nbsp;<wbr> mov<br> bh,0&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;显示的页数<br> &nbsp;<wbr> mov<br> al,1&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;显示的是串结构<br> &nbsp;<wbr> mov bl,0ch&nbsp;<wbr> ;显示的字符属性<br> &nbsp;<wbr> mov ah,13h&nbsp;<wbr> ;明确调用13h子程序<br> &nbsp;<wbr> msgstr: db “hello my os!”<br> &nbsp;<wbr> int 10h<br> &nbsp;<wbr> times 510-($-$$) db 0&nbsp;<wbr><br> ;重复n次每次填充值为0<br> &nbsp;<wbr> dw 55aah<br> &nbsp;<wbr> jmp<br> $&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;不断跳转到当前位置，是个死循环</p> 
         <p>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</p> 
         <p>;;;;;;;;;;;;;boot.asm;;;;;;;;;;;;;;;;;;</p> 
         <p>;我们的启动程序实现很简单的功能，在屏幕中央打印一行字符串即可</p> 
         <p>org 07c00h ;org指令明确告诉编译器我程序的段地址是7C00h，而不是原来的0000<br> ;int汇编指令 “int 10h”调用bois里的中断程序：显示字符串</p> 
         <p>&nbsp;<wbr> mov ax,cs<br> &nbsp;<wbr> mov es,ax<br> &nbsp;<wbr> mov bp,msgstr&nbsp;<wbr> ;es:bp<br> 指向的内容就是我们要显示的字符串地址了<br> &nbsp;<wbr><br> &nbsp;<wbr> mov<br> cx,12&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;显示的字符串长度<br> &nbsp;<wbr> mov<br> dh,12&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;显示的行号<br> &nbsp;<wbr> mov<br> dl,36&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;显示的列号<br> &nbsp;<wbr> mov<br> bh,0&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;显示的页数<br> &nbsp;<wbr> mov<br> al,1&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;显示的是串结构<br> &nbsp;<wbr> mov bl,0ch&nbsp;<wbr> ;显示的字符属性<br> &nbsp;<wbr><br> &nbsp;<wbr> mov ah,13h&nbsp;<wbr> ;明确调用13h子程序<br> &nbsp;<wbr><br> &nbsp;<wbr> msgstr: db “hello my os!”<br> &nbsp;<wbr> int 10h<br> &nbsp;<wbr> times 510-($-$$) db 0&nbsp;<wbr><br> ;重复n次每次填充值为0<br> &nbsp;<wbr> dw 55aah<br> &nbsp;<wbr> jmp<br> $&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;不断跳转到当前位置，是个死循环<br> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</p> 
         <p>/////////////////write_image.c//////////////////////</p> 
         <p>#include &lt;stdio.h&gt;<br> #include &lt;fcntl.h&gt;<br> #include &lt;sys/types.h&gt;<br> #include &lt;sys/stat.h&gt;</p> 
         <p>int main(int argc,char *argv[])<br> {<br> &nbsp;<wbr> int fd_source;<br> &nbsp;<wbr> int fd_dest;<br> &nbsp;<wbr> int read_count=0;<br> &nbsp;<wbr> char buffer[512]={0};<br> &nbsp;<wbr> fd_source=open(“boot.bin”,O_RDONLY);<br> &nbsp;<wbr> if(fd_source&lt;0)<br> &nbsp;<wbr> {<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> perror(“open<br> boot.bin error:”);<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> return<br> 0;<br> &nbsp;<wbr> }<br> &nbsp;<wbr> fd_dest=open(“v1.vfd”,O_WRONLY);<br> &nbsp;<wbr><br> while((read_count=read(fd_source,buffer,512))&gt;0)</p> 
         <p>&nbsp;<wbr> {<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> write(fd_dest,buffer,read_count);<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> memset(buffer,0,512);<br> &nbsp;<wbr> }<br> &nbsp;<wbr> printf(“write image ok!”);<br> &nbsp;<wbr> return 0;<br> }<br> ////////////////////////////////////////////</p> 
         <p> —————–13——————————–</p> 
         <p>主要内容<br> 实模式概念<br> 保护模式概念<br> 选择子<br> 段描述符<br> 系统地址寄存器</p> 
         <p>实模式概念<br> 计算机加电后，cpu就默认属于real-model(实模式)下<br> 实模式只能访问地址在1M以下的内存称为常规内存，我们把地址在1M以上的内存称为扩展内存。<br> seg:offset 20位地址，只能访问1M空间<br> 通过这种组合指向的内存地址就是实际的物理内存地址</p> 
         <p>32位cpu<br> intel退出32位cpu时完全兼容了16位cpu。<br> 所谓兼容其中很重要的一点就是可以继续使用16位的内存寻址方式。<br> &nbsp;<wbr> 大家都知道16cpu内存寻址是通过段寄存器：通用寄存器来表示实际的内存地址。<br> &nbsp;<wbr><br> 32位cpu地址线32根，最大内存为4GB，如何利用原来的seg:offset（实现20根地址线）表示方式，来表示32根地址线？</p> 
         <p>&nbsp;<wbr><br> 保护模式<br> 在保护模式下cpu依然使用段寄存器和通用寄存器来表示内存地址，但如何用20位地址来实现32位地址线寻址能力？<br> &nbsp;<wbr> 有张表，纪录段地址 开始地址 大小（段界限） 属性<br> &nbsp;<wbr> 16位段寄存器纪录表的【【索引】】<br> &nbsp;<wbr><br> 新的内容访问思路<br> 在实模式下，我们把内存分成一个个内存段来表示，那么在保护模式下内存也被分为一个个内存段表示。<br> 那么我们就把实现分好的内存段信息存入一张表格中，然后段寄存器中保存你要访问内存段所在的这张表格的索引。<br> &nbsp;<wbr> 保存表中索引的段寄存器，我们称为段选择子。<br> &nbsp;<wbr> 表中每个表示32位内存段信息我们称之为段描述符。<br> &nbsp;<wbr> 整张表称之为【【段描述符表】】。<br> &nbsp;<wbr><br> 段选择子<br> &nbsp;<wbr><br> 段选择子16位（段寄存器16位），其中高13位存放描述符表中的索引，其低3位用来表示段描述符表中所指向的段描述符的属性。<br> &nbsp;<wbr> 因此表中段描述符最大个数为2^13=8096个。<br> &nbsp;<wbr> TI(Table<br> Indicator)：用来表示是从全局描述符表中读取描述符还是从局部描述符表中读取描述符。<br> &nbsp;<wbr> RPL(Request Priviledge Level)：用于特权检查.<br> &nbsp;<wbr><br> 形成物理地址<br> &nbsp;<wbr><br> 段寄存器-（索引号）–&gt;段描述符表—&gt;段描述符A—&gt;线性地址空间(物理地址)&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 不考虑分页时，线性地址=物理地址</p> 
         <p>段描述符结构<br> &nbsp;<wbr> 既然段描述符包含了段的开始地址和段的界限，那么了解该结构至关重要<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 段描述符共8个字节，每个字节都具有具体含义<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 段界限(segment limit)20位被分为两个部分，第一部分保存在1，2字节中，第二部分保存在7<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 段基地址(segment base)32位被分成两个部分，第一部分23个字节被存放在3，4，5字节中，第二部分放在8<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 段属性(attributes)包含了该段属性和段界限的第二部分<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 段基地址剩余部分(base)包含了段界限剩余的8位<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
         <p>内存分配<br> &nbsp;<wbr> 由于我们现在编写的在裸机上编写程序，因此内存必须我们自己在4GB内存中进行分配<br> —————–14————————–</p> 
         <p>段属性<br> &nbsp;<wbr><br> 段属性位于段描述符的第6和第7个字节，用来描述该段是数据段还是代码段或者堆栈段，对于数据段或者堆栈段来说是否可读是否可写，<br> &nbsp;<wbr> 对于代码段来说是否可执行以及段描述符所指定的内存段在物理内存中是否存在。<br> &nbsp;<wbr> 从左往右<br> &nbsp;<wbr> 0~3 TYPE&nbsp;<wbr><br> ：说明存储段描述符所描述的存储段的具体属性。是属于代码段还是数据段，可读可写还是可执行。<br> &nbsp;<wbr><br> 4&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> DT&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ：说明了该描述符所指定的系统端描述符海华丝存储段描述符。<br> &nbsp;<wbr> 5~6<br> DPL&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ：表示描述符特权级别。<br> &nbsp;<wbr><br> 7&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> P&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ：表示描述符对地址的转换是否有效。<br> &nbsp;<wbr> 第二个字节<br> &nbsp;<wbr> 0~3 Limit ：段界限第二部分剩余的4位。<br> &nbsp;<wbr><br> 4&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> AVL&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ：软件可利用完，80386对该位未做规定<br> &nbsp;<wbr><br> 5&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ：0<br> &nbsp;<wbr><br> 6&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> D&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ：表示如果该段是代码段，是否是16位还是32位代码段，如果该段是数据段是否是16还是32位，1表示32位<br> &nbsp;<wbr><br> 7&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> G&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ：段界限粒度位G=0表示段边界64k，G=1表示段边界4GB<br> &nbsp;<wbr><br> 段界限<br> &nbsp;<wbr><br> 我们既然分了8M的内存段，那么段界限就是8M，那么8M占用多少字节，怎样用16进制表示并争取填充到段描述符中呢？<br> &nbsp;<wbr> 8M=2^23=800000H<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 不能直接把800000这个16进制直接写段描述符的相应位置中，并且20位的段界限 23位二进制数如何解决？<br> &nbsp;<wbr> 段界限公式<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 段界限=limit*4k+0FFFH<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 800000=limit*4k+0FFFH<br> &nbsp;<wbr> limit就是要填写到段描述符中的段界限位置<br> &nbsp;<wbr> limit=(800000-0FFFH)/4k=7FFH<br> &nbsp;<wbr><br> 段描述符的填写<br> &nbsp;<wbr> 我们的偏移地址都是通过8M通过公式得出段界限为7FF<br> &nbsp;<wbr> 我们第一个内存的段从内存00000处开始，所以段基地址全为0<br> &nbsp;<wbr><br> 那么我们创建的段位数据段并且是可读可写的，那么就必须在attributes字段中填写相应的数据。<br> &nbsp;<wbr><br> base&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> attributes&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> segment<br> base&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> segment limit<br> &nbsp;<wbr><br> 0000&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 000000000000&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 07FF<br> &nbsp;<wbr><br> &nbsp;<wbr> TYPE<br> ：我们定义的是数据段并且我们要求该段可读可写那么tpye值填为0010，如果我们创建的是代码段可读可执行，那么为1010<br> &nbsp;<wbr><br> DT&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ：DT用来区别系统段还是存储段，我们这边都是存储段。<br> &nbsp;<wbr> DPL&nbsp;<wbr> ：表示内存段的权限，这里为00表示<br> &nbsp;<wbr><br> P&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ：表示描述符对地址转换是否有效，1表示有效<br> &nbsp;<wbr> Limit：表示剩余4位段界限描述符 0000<br> &nbsp;<wbr> AVL&nbsp;<wbr> ：保留为0<br> &nbsp;<wbr><br> D&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ：1&nbsp;<wbr> 我们编写的是保护模式，32位<br> &nbsp;<wbr><br> G&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ：1<br> &nbsp;<wbr><br> 数据段描述符<br> &nbsp;<wbr> 根据以上内容我们可以定义符合数据段描述符的汇编代码<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> dw<br> 07FFh&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段界限<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> dw<br> 0h&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段基地址0~18位<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 0h&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段基地址19~23位<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 10010010b&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段描述符的第6个字节属性（数据段可读可写）<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 11000000b&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段描述符的第7个字节属性<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 0&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段描述符的最后一个字节也就是段基地址的第二部分<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
         <p>代码段描述符<br> &nbsp;<wbr> 代码段描述符和数据段描述符基本一致，不同在于段基地址和段属性<br> &nbsp;<wbr> dw<br> 07FFh&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段界限(保持不变)<br> &nbsp;<wbr> dw<br> 1h&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段基地址0~18位&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 不同<br> &nbsp;<wbr> db<br> 80h&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段基地址19~23位&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 不同<br> &nbsp;<wbr> db<br> 10011010b&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段描述符的第6个字节属性(代码段可读可执行)&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 不同<br> &nbsp;<wbr> db<br> 11000000b&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段描述符的第7个字节属性<br> &nbsp;<wbr> db<br> 0&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段基地址的第二部分<br> &nbsp;<wbr><br> &nbsp;<wbr><br> ———————-15———————————</p> 
         <p>Intel规定描述符表的第一个描述符必须是空描述符，也就是第一个描述符全部填充为0</p> 
         <p>DTR寄存器<br> &nbsp;<wbr> 全部定义好数据段和代码段描述符后，我们知道这个描述符表是存在了内存的某个位置，<br> &nbsp;<wbr> 那么CPU如何取得这描述符表所在的位置以及大小？<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 我们必须把刚刚创建好的描述符表所在地址和长度保存起来供CPU使用<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 80386CPU有个专门保存描述符表的48位寄存器称之为GDTR寄存器<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> GDTR寄存器共48位：32位描述符表基地址&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 16位描述符表界限</p> 
         <p>gdtr汇编指令<br> &nbsp;<wbr><br> 通过lgdt汇编指令可以把GDTR描述符表的大小和起始位置存入gdtr寄存器中，指令格式如下：<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> lgdt&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> [描述段描述符表的地址]<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
         <p>A20地址线<br> &nbsp;<wbr><br> 早期的8086只有20根地址线，只能访问1M的地址空间。CPU寻址则按段+偏移的方式进行。<br> &nbsp;<wbr> 在32位CPU情况下，如果内存访问到1M内存尾部时再向下访问将会出现什么情况？<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 16位段+16位偏移的可能范围是0-0x10FFEF(即0xFFFF0+0xFFFF)，即1M+65520自字节的范围。<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 由于只有20根地址线，所以在对1M~1M+65520范围进行访问时会发生“地址回绕”的现象，<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 就是说实际会访问到0~65520的地方。<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 在32位CPU下不会产生地址回绕，但有些16位程序正是利用地址回绕特性来编写的，<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 那么如何兼容这些程序呢？<br> &nbsp;<wbr> 让32位德二进制数据高12位清空为0，剩下的低20二进制数，如何实现呢。<br> &nbsp;<wbr> 我们只让32位数据和高全为0低全为1的数相与操作。</p> 
         <p>;;;;;;;;;;;;;;;;;;;boot.asm,增加了gdt_data等;;;;;;;;;;;;;;;;;;;;;;;;;;</p> 
         <p>;我们的启动程序实现很简单的功能，在屏幕中央打印一行字符串即可</p> 
         <p>org 07c00h ;org指令明确告诉编译器我程序的段地址是7C00h，而不是原来的0000<br> ;int汇编指令 “int 10h”调用bois里的中断程序：显示字符串<br> gdt_table_start:<br> &nbsp;<wbr> gdt_null:<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> dd 0h<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> dd<br> 0h&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;Intel规定段描述符表的第一个表项必须为0<br> &nbsp;<wbr><br> gdt_data_addr&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> equ&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> $-gdt_table_start<br> &nbsp;<wbr> gdt_data:<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> dw<br> 07FFh&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段界限<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> dw<br> 0h&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段基地址0~18位<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 0h&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段基地址19~23位<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 10010010b&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段描述符的第6个字节属性（数据段可读可写）<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 11000000b&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段描述符的第7个字节属性<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 0&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段描述符的最后一个字节也就是段基地址的第二部分<br> &nbsp;<wbr><br> gdt_code_addr&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> equ&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> $-gdt_table_start<br> &nbsp;<wbr> gdt_code:<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> dw<br> 07FFh&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段界限(保持不变)<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> dw<br> 1h&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段基地址0~18位&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 不同<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 80h&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段基地址19~23位&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 不同<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 10011010b&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段描述符的第6个字节属性(代码段可读可执行)&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 不同<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 11000000b&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段描述符的第7个字节属性<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 0&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段基地址的第二部分<br> gdt_table_end:<br> &nbsp;<wbr> gdtr_addr:<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> dw<br> gdt_table_end-gdt_table_start-1&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ; 段描述符表长度<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> dd<br> gdt_table_start&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ; 段描述符表基地址<br> &nbsp;<wbr> lgdt&nbsp;<wbr><br> [gdtr_addr]&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;让CPU读取gdtr_addr所指向内存内容保存到GDT内存当中</p> 
         <p>;A20地址线问题</p> 
         <p>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</p> 
         <p> ———————–16—————————————</p> 
         <p>A20地址线<br> &nbsp;<wbr><br> 由于在当时的8042键盘控制器上恰好有空闲的端口引脚，于是使用了该引脚昨晚与门控制这个地址比特位。<br> &nbsp;<wbr> 该信号即被称为A20。如果它为0，则比特20及以上地址都被清除。从而实现了兼容性。<br> &nbsp;<wbr> 由于键盘的控制器速度很慢，因此就不能使用键盘对A20线来进行操作，<br> &nbsp;<wbr> 为此引进了一个A20快速门选项(Fast Gate<br> A20)，它使用I/O端口0x92来处理A20信号线，避免了使用慢速的键盘控制器操作方式。<br> &nbsp;<wbr><br> 端口概念<br> &nbsp;<wbr><br> 在计算机系统中，所有设备都和CPU相连接，尽管相连接但CPU不能直接跟外围设备进行交互数据,<br> &nbsp;<wbr> CPU只能和每个设备的寄存器交互数据，然后再由寄存器把数据传给设备。<br> &nbsp;<wbr> 那么我们给每个设备的寄存器进行编号，这些编号就称之为【【端口号】】。</p> 
         <p>端口的读<br> &nbsp;<wbr> 我们用in汇编命令来读取设备寄存器中的内容，格式如下：<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> in accum port<br> &nbsp;<wbr><br> 其中port就是要读取的端口号，accum表示把port端口号的内容放到accum中。accum必须是AL或者AX。<br> &nbsp;<wbr> 该命令的含义就是读取port端口号内容到AL或者AX寄存器中。</p> 
         <p>端口的写<br> &nbsp;<wbr> 我们使用out汇编指令往指定设备中写入数据，格式如下：<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> out port accume<br> &nbsp;<wbr> 该命令含义是把accume中的值写入port端口中。</p> 
         <p>开启A20地址线<br> &nbsp;<wbr><br> 32位计算机加电时默认情况是关闭A20地址线的，CPU要转入保护模式都必须开启A20地址线，如何开启呢？<br> &nbsp;<wbr> A20地址线代码如下：<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> in&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> al,92h<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> or&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> al,00000010b<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> out&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 92h,al</p> 
         <p>cli汇编指令<br> &nbsp;<wbr> 在转入保护模式之前，我们必须废除原来的中断向量表。<br> &nbsp;<wbr> 在汇编语言中使用cli汇编指令来废除实模式下的中断向量表。<br> &nbsp;<wbr> 这就意味着在保护模式下必须重新建立32位的中断向量表和中断处理程序。<br> &nbsp;<wbr><br> 转入保护模式<br> &nbsp;<wbr> 当我们一切准备好之后，如何明确的告诉CPU我们要进入保护模式？<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 80386提供了4个32位的控制寄存器CR0~CR3。<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 其中控制寄存器CR0中某些位时用来标识是否要进入保护模式。<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> CR1寄存器保留没有被使用。<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> CR2和CR3用于分页机制（不属于讨论范围）<br> &nbsp;<wbr><br> CR0寄存器<br> &nbsp;<wbr><br> 31&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> PG&nbsp;<wbr><br> 控制分页管理机制。PG=0，禁用分页管理机制，此时分段管理机制产生的线性地址直接作为物理地址使用。<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> PG=1，启用分页管理机制，此时线性地址经分页管理机制转换物理地址。<br> &nbsp;<wbr> 30~5<br> &nbsp;<wbr><br> 4&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ET<br> &nbsp;<wbr><br> 3&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> TS<br> &nbsp;<wbr><br> 2&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> EM<br> &nbsp;<wbr><br> 1&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> MP<br> &nbsp;<wbr><br> 0&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> PE&nbsp;<wbr> 控制分段管理机制，PE=0，处理器运行于实模式;PE=1，处理器处于保护模式</p> 
         <p>设置CR0寄存器<br> &nbsp;<wbr><br> 只要对CR0寄存器的第一位置设为1，就表示要转入保护模式，那么在汇编代码中如何实现呢？<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> mov eax,cr0<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> or&nbsp;<wbr> eax,1<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> mov cr0,eax<br> &nbsp;<wbr><br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
         <p>———————–17—————–<br> —&nbsp;<wbr>&nbsp;<wbr></p> 
         <p>保护模式下段寄存器<br> &nbsp;<wbr> 在386保护模式下，CPU的物理内存依然是段寄存器内容加偏移地址形成线性地址。<br> &nbsp;<wbr> 段寄存器内容表示段描述符表中的索引（或者说段描述符所在的段描述符表的位置）。</p> 
         <p> ———————–18———————</p> 
         <p>bochs是c++编写的开源跨平台的虚拟机，具有良好的可移植性。可以对操作系统进行调试时它最大的特色。<br> &nbsp;<wbr> continue(c) 程序继续运行知道遇到断点为止。<br> &nbsp;<wbr><br> step(s)&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 单步跟踪。<br> &nbsp;<wbr> vbreak(vb)&nbsp;<wbr><br> 在虚拟地址上设置一个断点。&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> vb 段地址：偏移地址<br> &nbsp;<wbr><br> pbreak(b)&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 在物理地址上设置一个断点。&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
         <p>&nbsp;<wbr> lbreak(lb)&nbsp;<wbr> 在线性地址上设置一个断点。<br> &nbsp;<wbr> disassemble 反汇编指令。<br> &nbsp;<wbr><br> &nbsp;<wbr> info b&nbsp;<wbr> 显示断点<br> &nbsp;<wbr><br> &nbsp;<wbr><br> ———————–19———————</p> 
         <p>bug<br> &nbsp;<wbr><br> 我们实际的代码段和数据段的基地址是由我们代码中的data_32和code_32来表示的。<br> &nbsp;<wbr> 我们要修改代码段描述符和数据段描述符跟段基地址有关的字节。<br> &nbsp;<wbr> 根据描述结构我们只要修改3，4，5，8这几个字节的内容，填上我们新的及地址就可以了。</p> 
         <p>;;;;;;;;;;;;;;;;;;;boot.asm;;;;;;;;;;;;;;;;;;;;;;;;<br> ;我们的启动程序实现很简单的功能，在屏幕中央打印一行字符串即可<br> [BITS 16]<br> org 07c00h ;org指令明确告诉编译器我程序的段地址是7C00h，而不是原来的0000<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;int汇编指令 “int 10h”调用bois里的中断程序：显示字符串<br> jmp main<br> gdt_table_start:<br> &nbsp;<wbr> gdt_null:<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> dd 0h<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> dd<br> 0h&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;Intel规定段描述符表的第一个表项必须为0<br> &nbsp;<wbr><br> gdt_data_addr&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> equ&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> $-gdt_table_start<br> &nbsp;<wbr> gdt_data:<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> dw<br> 07FFh&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段界限<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> dw<br> 0h&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段基地址0~18位<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 0h&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段基地址19~23位<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 10010010b&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段描述符的第6个字节属性（数据段可读可写）<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 11000000b&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段描述符的第7个字节属性<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 0&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段描述符的最后一个字节也就是段基地址的第二部分<br> &nbsp;<wbr><br> gdt_video_addr&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> equ&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> $-gdt_table_start<br> &nbsp;<wbr><br> gdt_video:&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;用来描述显存地址空间的段描述符<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> dw&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 0FFh&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;显存段界限就是1M<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> dw&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 8000h&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
         <p>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 0Bh<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 10010010b<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 11000000b<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 0<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
         <p>&nbsp;<wbr><br> gdt_code_addr&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> equ&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> $-gdt_table_start<br> &nbsp;<wbr> gdt_code:<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> dw<br> 07FFh&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段界限(保持不变)<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> dw<br> 1h&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段基地址0~18位&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 不同<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 80h&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段基地址19~23位&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 不同<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 10011010b&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段描述符的第6个字节属性(代码段可读可执行)&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 不同<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 11000000b&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段描述符的第7个字节属性<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> db<br> 0&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;段基地址的第二部分<br> gdt_table_end:<br> &nbsp;<wbr> gdtr_addr:<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> dw<br> gdt_table_end-gdt_table_start-1&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ; 段描述符表长度<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> dd<br> gdt_table_start&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ; 段描述符表基地址</p> 
         <p>&nbsp;<wbr></p> 
         <p>;A20地址线问题<br> main:<br> &nbsp;<wbr> xor eax,eax<br> &nbsp;<wbr> add eax,data_32<br> &nbsp;<wbr> mov word [gdt_data+2],ax<br> &nbsp;<wbr> shr eax,16<br> &nbsp;<wbr> mov byte [gdt_data+4],al<br> &nbsp;<wbr> mov byte [gdt_data+7],ah<br> &nbsp;<wbr><br> &nbsp;<wbr> xor eax,eax<br> &nbsp;<wbr> add eax,code_32<br> &nbsp;<wbr> mov word [gdt_code+2],ax<br> &nbsp;<wbr> shr eax,16<br> &nbsp;<wbr> mov byte [gdt_code+4],al<br> &nbsp;<wbr> mov byte [gdt_code+7],ah<br> &nbsp;<wbr> ;初始化代码段描述符的基地址<br> &nbsp;<wbr><br> &nbsp;<wbr> cli<br> &nbsp;<wbr> lgdt&nbsp;<wbr><br> [gdtr_addr]&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;让CPU读取gdtr_addr所指向内存内容保存到GDT内存当中<br> &nbsp;<wbr> enable_a20:<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> in&nbsp;<wbr> al,92h<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> or&nbsp;<wbr> al,00000010b<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> out 92h,al<br> &nbsp;<wbr><br> &nbsp;<wbr> ;设置cr0寄存器第一位为1<br> &nbsp;<wbr> mov eax,cr0<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> or&nbsp;<wbr> eax,1<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> mov cr0,eax<br> &nbsp;<wbr> ;跳转到保护模式中<br> &nbsp;<wbr> jmp gdt_code_addr:0<br> [BITS 32]<br> &nbsp;<wbr> ;保护模式的功能就是屏幕中央打印hello world<br> &nbsp;<wbr> data_32:<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> db “hello<br> world”<br> &nbsp;<wbr> code_32:<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov<br> ax,gdt_data_addr<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov<br> ds,ax<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov<br> ax,gdt_video_addr<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov<br> gs,ax<br> &nbsp;<wbr><br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov<br> cx,11&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;显示的字符串长度<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov<br> edi,(80*10+12)*2&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> ;在屏幕中央显示<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov<br> bx,0<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov<br> ah,0ch<br> &nbsp;<wbr> s:mov al,[ds:bx]<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov<br> [gs:edi],al<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov<br> [gs:edi+1],ah<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> inc bx<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> add<br> edi,2<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> loop s<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> jmp $<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> times<br> 510-($-$$) db 0<br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> dw<br> 0aa55h<br> </p> 
        </div>
       </div>
       <!-- .entry-content --> 
       <!-- .entry-meta --> 
      </article>
      <!-- #post-213 --> 
      <!-- #comments --> 
     </div>
     <!-- #content --> 
    </div>
    <!-- #primary --> 
    <!-- #secondary .widget-area --> 
   </div>
   <!-- #main --> 
   <!-- #colophon --> 
  </div>
  <!-- #page -->   
  <!-- JiaThis Button BEGIN -->  
  <!-- JiaThis Button END -->   
 </body>
</html>