<!doctype html>
<!--[if IE 6]>
<html id="ie6" lang="zh-CN">
<![endif]-->
<!--[if IE 7]>
<html id="ie7" lang="zh-CN">
<![endif]-->
<!--[if IE 8]>
<html id="ie8" lang="zh-CN">
<![endif]-->
<!--[if !(IE 6) | !(IE 7) | !(IE 8)  ]><!-->
<html lang="zh-CN">
 <!--<![endif]-->
 <head>      
  <link rel="stylesheet" type="text/css" media="all" href="stylesheets/style.css">     
  <link rel="stylesheet" id="codebox-css" href="stylesheets/codebox.css" type="text/css" media="screen">             
 </head> 
 <body class="single single-post postid-38 single-format-standard content-sidebar"> 
  <div id="page" class="hfeed"> 
   <header id="branding" role="banner"> 
    <hgroup> 
     <h1 id="site-title"><span><a href="http://codelifeliwan.github.io/" title="Code_Life_LiWan" rel="home">Code_Life_LiWan</a></span></h1> 
     <h2 id="site-description">My heart will go on and on…</h2> 
    </hgroup>  
    <!-- #access --> 
   </header>
   <!-- #branding --> 
   <div id="main" class="clearfix"> 
    <div id="primary"> 
     <div id="content" role="main"> 
      <!-- #nav-single --> 
      <article id="post-38" class="post-38 post type-post status-publish format-standard hentry category-professional_exchanges tag-reserved"> 
       <header class="entry-header"> 
        <h1 class="entry-title">[转载]sizeof用法大全</h1> 
        <div class="entry-meta"> 
         <span class="sep">Posted on </span>
         <a href="http://codelifeliwan.github.io/?p=38" title="下午 8:05" rel="bookmark"><time class="entry-date" datetime="2011-05-29T20:05:46+00:00" pubdate>29 五月, 2011</time></a>
         <span class="by-author"> <span class="sep"> by </span> <span class="author vcard"><a class="url fn n" href="http://codelifeliwan.github.io/?author=1" title="View all posts by wanli" rel="author">wanli</a></span></span> 
         <span class="sep"> — </span> 
         <span class="comments-link"> <a href="http://codelifeliwan.github.io/?p=38#comments" title="Comment on [转载]sizeof用法大全">1 Comment ↓</a> </span> 
        </div>
        <!-- .entry-meta --> 
       </header>
       <!-- .entry-header --> 
       <div class="entry-content">
        <div class="entry-content"> 
         <div class="blogzz_abstract borderc" style="padding-top:15px;margin:20px 0; border:none; border-top:1px dotted #ccc;"> 
          <div class="blogzz_ainfo" style="margin-bottom:12px;"> 
           <span style="margin-right:25px;"><strong>原文地址：</strong><a target="_blank" href="http://blog.sina.com.cn/s/blog_6de0b7b90100uwvv.html" title="sizeof用法大全">sizeof用法大全</a></span> 
           <span><strong>作者：</strong><a href="http://blog.sina.com.cn/u/1843443641" title="ZealTim_Leo" target="_blank">ZealTim_Leo</a></span> 
          </div> 
          <div class="blogzz_acon"> 
           <p align="right"><a href="http://apps.hi.baidu.com/share/detail/36483062">修改浏览权限</a> |<br> <a href="http://apps.hi.baidu.com/share/detail/36483062">删除</a></p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 关于sizeof(string)，今天看那本面试宝典的时候看到这个表达式，有点吃惊，书上写着sizeof(string)=4;当时很纳闷，难道分配4个字节大小的内存给string吗？查阅了相关资料得出结论：string的实现在各库中可能有所不同，但是在同一库中相同一点是，无论你的string里放多长的字符串，它的sizeof()都是固定的，字符串所占的空间是从堆中动态分配的，与sizeof()无关。&nbsp;<wbr>&nbsp;<wbr></p> 
           <p>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> sizeof(string)=4可能是最典型的实现之一，不过也有sizeof()为12、32字节的库实现。<br> 但是VC6.0测试后sizeof(string)=16.还是跟编译器有关</p> 
           <p align="left"> #include&lt;iostream&gt;<br> using namespace std;<br> void main(void)<br> {<br> string a[] = {“aaaaa”,”bbbb”,”ccc”};<br> int x = sizeof(a);<br> int y = sizeof(string);<br> cout &lt;&lt; x<br> &lt;&lt; endl;<br> cout &lt;&lt; y<br> &lt;&lt; endl;<br> }</p> 
           <p align="left">运行结果：</p> 
           <p align="left">&nbsp;<wbr></p> 
           <p align="left">关于sizeof更多的用法摘自：<a href="http://hi.baidu.com/haijiaoshu/blog/item/a269f527706b910a908f9d5b.html" target="_blank">http://hi.baidu.com/haijiaoshu/blog/item/a269f527706b910a908f9d5b<wbr>.html</a></p> 
           <p align="left">1、什么是sizeof</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 首先看一下sizeof在msdn上的定义：</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> The sizeof<br> keyword gives the amount of storage, in bytes, associated with a<br> variable or a type (including aggregate types). This keyword<br> returns a value of type size_t.</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 看到return这个字眼，是不是想到了函数？错了，sizeof不是一个函数，你见过给一个函数传参数，而不加括号的吗？sizeof可以，所以sizeof不是函数。网上有人说sizeof是一元操作符，但是我并不这么认为，因为sizeof更像一个特殊的宏，它是在编译阶段求值的。举个例子：</p> 
           <p align="left"> cout&lt;&lt;sizeof(int)&lt;&lt;endl;<br> // 32位机上int长度为4</p> 
           <p align="left"> cout&lt;&lt;sizeof(1==2)&lt;&lt;endl;<br> // == 操作符返回bool类型，相当于<br> cout&lt;&lt;sizeof(bool)&lt;&lt;endl;</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 在编译阶段已经被翻译为：</p> 
           <p align="left"> cout&lt;&lt;4&lt;&lt;endl;</p> 
           <p align="left"> cout&lt;&lt;1&lt;&lt;endl;</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 这里有个陷阱，看下面的程序：</p> 
           <p align="left">int a = 0;</p> 
           <p align="left"> cout&lt;&lt;sizeof(a=3)&lt;&lt;endl;</p> 
           <p align="left"> cout&lt;&lt;a&lt;&lt;endl;</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 输出为什么是4，0而不是期望中的4，3？？？就在于sizeof在编译阶段处理的特性。由于sizeof不能被编译成机器码，所以sizeof作用范围内，也就是()里面的内容也不能被编译，而是被替换成类型。=操作符返回左操作数的类型，所以a=3相当于int，而代码也被替换为：</p> 
           <p align="left">int a = 0;</p> 
           <p align="left"> cout&lt;&lt;4&lt;&lt;endl;</p> 
           <p align="left"> cout&lt;&lt;a&lt;&lt;endl;</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 所以，sizeof是不可能支持链式表达式的，这也是和一元操作符不一样的地方。</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 结论：不要把sizeof当成函数，也不要看作一元操作符，把他当成一个特殊的编译预处理。</p> 
           <p align="left">2、sizeof的用法</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> sizeof有两种用法：</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> （1）sizeof(object)</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 也就是对对象使用sizeof，也可以写成sizeof object 的形式。例如：</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> （2）sizeof(typename)</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 也就是对类型使用sizeof，注意这种情况下写成sizeof typename是非法的。下面举几个例子说明一下：</p> 
           <p align="left">int i = 2;</p> 
           <p align="left"> cout&lt;&lt;sizeof(i)&lt;&lt;endl;<br> // sizeof(object)的用法，合理</p> 
           <p align="left">cout&lt;&lt;sizeof<br> i&lt;&lt;endl; // sizeof object的用法，合理</p> 
           <p align="left">cout&lt;&lt;sizeof<br> 2&lt;&lt;endl; // 2被解析成int类型的object, sizeof<br> object的用法，合理</p> 
           <p align="left"> cout&lt;&lt;sizeof(2)&lt;&lt;endl;<br> // 2被解析成int类型的object, sizeof(object)的用法，合理</p> 
           <p align="left"> cout&lt;&lt;sizeof(int)&lt;&lt;endl;//<br> sizeof(typename)的用法，合理</p> 
           <p align="left">cout&lt;&lt;sizeof<br> int&lt;&lt;endl; // 错误！对于操作符，一定要加()</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 可以看出，加()是永远正确的选择。</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 结论：不论sizeof要对谁取值，最好都加上()。</p> 
           <p align="left">3、数据类型的sizeof</p> 
           <p align="left">（1）C++固有数据类型</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 32位C++中的基本数据类型，也就char,short int(short),int,long<br> int(long),float,double, long double</p> 
           <p align="left">大小分别是：1，2，4，4，4，8, 10。</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 考虑下面的代码：</p> 
           <p align="left">cout&lt;&lt;sizeof(unsigned<br> int) == sizeof(int)&lt;&lt;endl; // 相等，输出<br> 1</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> unsigned影响的只是最高位bit的意义，数据长度不会被改变的。</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 结论：unsigned不能影响sizeof的取值。</p> 
           <p align="left">（2）自定义数据类型</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> typedef可以用来定义C++自定义类型。考虑下面的问题：</p> 
           <p align="left">typedef short WORD;</p> 
           <p align="left">typedef long DWORD;</p> 
           <p align="left">cout&lt;&lt;(sizeof(short)<br> == sizeof(WORD))&lt;&lt;endl; // 相等，输出1</p> 
           <p align="left">cout&lt;&lt;(sizeof(long)<br> == sizeof(DWORD))&lt;&lt;endl; //<br> 相等，输出1</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 结论：自定义类型的sizeof取值等同于它的类型原形。</p> 
           <p align="left">（3）函数类型</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 考虑下面的问题：</p> 
           <p align="left">int f1(){return 0;};</p> 
           <p align="left">double f2(){return 0.0;}</p> 
           <p align="left">void f3(){}</p> 
           <p align="left"> cout&lt;&lt;sizeof(f1())&lt;&lt;endl;<br> // f1()返回值为int，因此被认为是int</p> 
           <p align="left"> cout&lt;&lt;sizeof(f2())&lt;&lt;endl;<br> // f2()返回值为double，因此被认为是double</p> 
           <p align="left"> cout&lt;&lt;sizeof(f3())&lt;&lt;endl;<br> // 错误！无法对void类型使用sizeof</p> 
           <p align="left"> cout&lt;&lt;sizeof(f1)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> //<br> 错误！无法对函数指针使用sizeof&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left"> cout&lt;&lt;sizeof*f2&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // *f2，和f2()等价，因为可以看作object，所以括号不是必要的。被认为是double</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 结论：对函数使用sizeof，在编译阶段会被函数返回值的类型取代，</p> 
           <p align="left">4、指针问题</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 考虑下面问题：</p> 
           <p align="left"> cout&lt;&lt;sizeof(string*)&lt;&lt;endl;<br> // 4</p> 
           <p align="left"> cout&lt;&lt;sizeof(int*)&lt;&lt;endl;<br> // 4</p> 
           <p align="left"> cout&lt;&lt;sizof(char****)&lt;&lt;endl;<br> // 4</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 可以看到，不管是什么类型的指针，大小都是4的，因为指针就是32位的物理地址。</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 结论：只要是指针，大小就是4。（64位机上要变成8也不一定）。</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 顺便唧唧歪歪几句，C++中的指针表示实际内存的地址。和C不一样的是，C++中取消了模式之分，也就是不再有small,middle,big,取而代之的是统一的flat。flat模式采用32位实地址寻址，而不再是c中的<br> segment:offset模式。举个例子，假如有一个指向地址 f000:8888的指针，如果是C类型则是8888(16位,<br> 只存储位移，省略段)，far类型的C指针是f0008888(32位，高位保留段地址，地位保留位移),C++类型的指针是f8888(32位，相当于段地址*16<br> + 位移，但寻址范围要更大)。</p> 
           <p align="left">5、数组问题</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 考虑下面问题：</p> 
           <p align="left">char a[] = “abcdef”;</p> 
           <p align="left">int b[20] = {3, 4};</p> 
           <p align="left">char c[2][3] = {“aa”, “bb”};</p> 
           <p align="left"> cout&lt;&lt;sizeof(a)&lt;&lt;endl;<br> // 7</p> 
           <p align="left"> cout&lt;&lt;sizeof(b)&lt;&lt;endl;<br> // 20*4=80</p> 
           <p align="left"> cout&lt;&lt;sizeof(c)&lt;&lt;endl;<br> // 6</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 数组a的大小在定义时未指定，编译时给它分配的空间是按照初始化的值确定的，也就是7。c是多维数组，占用的空间大小是各维数的乘积，也就是6。可以看出，数组的大小就是他在编译时被分配的空间，也就是各维数的乘积*数组元素的大小。</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 结论：数组的大小是各维数的乘积*数组元素的大小。</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 这里有一个陷阱：</p> 
           <p align="left">int *d = new int[10];</p> 
           <p align="left"> cout&lt;&lt;sizeof(d)&lt;&lt;endl;<br> // 4</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> d是我们常说的动态数组，但是他实质上还是一个指针，所以sizeof(d)的值是4。</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 再考虑下面的问题：</p> 
           <p align="left">double* (*a)[3][6];</p> 
           <p align="left"> cout&lt;&lt;sizeof(a)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 4</p> 
           <p align="left"> cout&lt;&lt;sizeof(*a)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 72</p> 
           <p align="left"> cout&lt;&lt;sizeof(**a)&lt;&lt;endl;<br> // 24</p> 
           <p align="left"> cout&lt;&lt;sizeof(***a)&lt;&lt;endl;<br> // 4</p> 
           <p align="left"> cout&lt;&lt;sizeof(****a)&lt;&lt;endl;<br> // 8</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> a是一个很奇怪的定义，他表示一个指向 double*[3][6]类型数组的指针。既然是指针，所以sizeof(a)就是4。</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 既然a是执行double*[3][6]类型的指针，*a就表示一个double*[3][6]的多维数组类型，因此sizeof(*a)=3*6*sizeof(double*)=72。同样的，**a表示一个double*[6]类型的数组，所以sizeof(**a)=6*sizeof(double*)=24。***a就表示其中的一个元素，也就是double*了，所以sizeof(***a)=4。至于****a，就是一个double了，所以sizeof(****a)=sizeof(double)=8。</p> 
           <p align="left">6、向函数传递数组的问题。</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 考虑下面的问题：</p> 
           <p align="left">#include<br> &lt;iostream&gt;</p> 
           <p align="left">using namespace std;</p> 
           <p align="left">int Sum(int i[])</p> 
           <p align="left">{</p> 
           <p align="left">int sumofi = 0;</p> 
           <p align="left">for (int j = 0; j &lt;<br> sizeof(i)/sizeof(int); j++) //实际上，sizeof(i) = 4</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> sumofi +=<br> i[j];</p> 
           <p align="left">}</p> 
           <p align="left">return sumofi;</p> 
           <p align="left">}</p> 
           <p align="left">int main()</p> 
           <p align="left">{</p> 
           <p align="left">int allAges[6] = {21, 22, 22, 19, 34, 12};</p> 
           <p align="left"> cout&lt;&lt;Sum(allAges)&lt;&lt;endl;</p> 
           <p align="left">system(“pause”);</p> 
           <p align="left">return 0;</p> 
           <p align="left">}</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> <b>Sum</b><b>的本意是用</b><b>sizeof</b><b>得到数组的大小，然后求和。但是实际上，传入自函数</b><b>Sum</b><b>的，只是一个</b><b>int</b><br> <b>类型的指针，所以</b><b>sizeof(i)=4</b><b>，而不是</b><b>24</b><b>，所以会产生错误的结果。解决这个问题的方法使是用指针或者引用。</b><b>&nbsp;</b><wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 使用指针的情况：&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left">int Sum(int<br> <b>(*i)</b>[6])&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left"> {&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left">int sumofi =<br> 0;&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left">for (int j = 0; j &lt;<br> sizeof(*i)/sizeof(int); j++) //sizeof(*i) = 24</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> sumofi +=<br> (*i)[j];</p> 
           <p align="left">}</p> 
           <p align="left">return sumofi;</p> 
           <p align="left">}</p> 
           <p align="left">int main()</p> 
           <p align="left"> {&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left">int allAges[] = {21, 22, 22, 19, 34,<br> 12};&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left"> cout&lt;&lt;Sum(<b>&amp;allAges</b>)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left"> system(“pause”);&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left">return<br> 0;&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left"> }&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 在这个Sum里，i是一个指向i[6]类型的指针，注意，<b>这里不能用</b><b>int Sum(int<br> (*i)[])</b><b>声明函数，而是必须指明要传入的数组的大小，不然</b><b>sizeof(*i)</b><b>无法计算。</b>但是在这种情况下，再通过sizeof来计算数组大小已经没有意义了，因为此时大小是指定为6的。&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left"> 使用引用的情况和指针相似：&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left">int Sum(int<br> <b>(&amp;i)</b>[6])&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> //传假名</p> 
           <p align="left">{</p> 
           <p align="left">int sumofi = 0;</p> 
           <p align="left">for (int j = 0; j &lt;<br> sizeof(i)/sizeof(int); j++)</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> sumofi +=<br> i[j];</p> 
           <p align="left">}</p> 
           <p align="left">return sumofi;</p> 
           <p align="left">}</p> 
           <p align="left">int main()</p> 
           <p align="left">{</p> 
           <p align="left">int allAges[] = {21, 22, 22, 19, 34,<br> 12};&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left"> cout&lt;&lt;Sum(<b>allAges</b>)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left"> system(“pause”);&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left">return<br> 0;&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left"> }&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 这种情况下sizeof的计算同样无意义，所以用数组做参数，而且需要遍历的时候，函数应该有一个参数来说明数组的大小，而数组的大小在数组定义的作用域内通过sizeof求值。因此上面的函数正确形式应该是：&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></p> 
           <p align="left">#include<br> &lt;iostream&gt;</p> 
           <p align="left">using namespace std;</p> 
           <p align="left">int Sum(int *i, unsigned int n)</p> 
           <p align="left">{</p> 
           <p align="left">int sumofi = 0;</p> 
           <p align="left">for (int j = 0; j &lt; n; j++)</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> sumofi +=<br> i[j];</p> 
           <p align="left">}</p> 
           <p align="left">return sumofi;</p> 
           <p align="left">}</p> 
           <p align="left">int main()</p> 
           <p align="left">{</p> 
           <p align="left">int allAges[] = {21, 22, 22, 19, 34, 12};</p> 
           <p align="left">cout&lt;&lt;Sum(i,<br> sizeof(allAges)/sizeof(int))&lt;&lt;endl;</p> 
           <p align="left">system(“pause”);</p> 
           <p align="left">return 0;</p> 
           <p align="left">}</p> 
           <p align="left">7、字符串的sizeof和strlen</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 考虑下面的问题：</p> 
           <p align="left">char a[] = “abcdef”;</p> 
           <p align="left">char b[20] = “abcdef”;</p> 
           <p align="left">string s = “abcdef”;</p> 
           <p align="left"> cout&lt;&lt;strlen(a)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 6，字符串长度</p> 
           <p align="left"> cout&lt;&lt;sizeof(a)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 7，字符串容量</p> 
           <p align="left"> cout&lt;&lt;strlen(b)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 6，字符串长度</p> 
           <p align="left"> cout&lt;&lt;sizeof(b)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 20，字符串容量</p> 
           <p align="left"> cout&lt;&lt;sizeof(s)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 12, 这里不代表字符串的长度，而是string类的大小</p> 
           <p align="left"> cout&lt;&lt;strlen(s)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 错误！s不是一个字符指针。</p> 
           <p align="left">a[1] = ”;</p> 
           <p align="left"> cout&lt;&lt;strlen(a)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 1</p> 
           <p align="left"> cout&lt;&lt;sizeof(a)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 7，sizeof是恒定的</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> strlen是寻找从指定地址开始，到出现的第一个0之间的字符个数，他是在运行阶段执行的，而sizeof是得到数据的大小，在这里是得到字符串的容量。所以对同一个对象而言，sizeof的值是恒定的。string是C++类型的字符串，他是一个类，所以sizeof(s)表示的并不是字符串的长度，而是类string的大小。strlen(s)根本就是错误的，因为strlen的参数是一个字符指针，如果想用strlen得到s字符串的长度，应该使用sizeof(s.c_str())，因为string的成员函数c_str()返回的是字符串的首地址。<b>实际上，</b><b>string</b><b>类提供了自己的成员函数来得到字符串的容量和长度，分别是</b><b>Capacity()</b><b>和</b><b>Length()</b><b>。</b><b>string</b><b>封装了常用了字符串操作，所以在</b><b>C++</b><b>开发过程中，最好使用</b><b>string</b><b>代替</b><b>C</b><b>类型的字符串。</b></p> 
           <p align="left">8、从union的sizeof问题看cpu的对界</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 考虑下面问题：（默认对齐方式）</p> 
           <p align="left">union u</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> double a;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> int b;</p> 
           <p align="left">};</p> 
           <p align="left">union u2</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> char<br> a[13];</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> int b;</p> 
           <p align="left">};</p> 
           <p align="left">union u3</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> char<br> a[13];</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> char b;</p> 
           <p align="left">};</p> 
           <p align="left"> cout&lt;&lt;sizeof(u)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 8</p> 
           <p align="left"> cout&lt;&lt;sizeof(u2)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 16</p> 
           <p align="left"> cout&lt;&lt;sizeof(u3)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 13</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 都知道<b>union</b><b>的大小取决于它所有的成员中，占用空间最大的一个成员的大小。</b>所以对于u来说，大小就是最大的double类型成员a了，所以sizeof(u)=sizeof(double)=8。但是对于u2和u3，最大的空间都是char[13]类型的数组，为什么u3的大小是13，而u2是16呢？关键在于u2中的成员int<br> b。<b>由于</b><b>int</b><b>类型成员的存在，使</b><b>u2</b><b>的对齐方式变成</b><b>4</b><b>，也就是说，</b><b>u2</b><b>的大小必须在</b><b>4</b><b>的对界上，所以占用的空间变成了</b><b>16</b><b>（最接近</b><b>13</b><b>的对界）。</b></p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 结论：<b><u>复合数据类型，如</u></b><b><u>union</u></b><b><u>，</u></b><b><u>struct</u></b><b><u>，</u></b><b><u>class</u></b><b><u>的对齐方式为成员中对齐方式最大的成员的对齐方式。</u></b></p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 顺便提一下CPU对界问题，32的C++采用8位对界来提高运行速度，所以编译器会尽量把数据放在它的对界上以提高内存命中率。对界是可以更改的，使用#pragma<br> pack(x)宏可以改变编译器的对界方式，默认是8。C++固有类型的对界取编译器对界方式与自身大小中较小的一个。例如，指定编译器按2对界，int类型的大小是4，则int的对界为2和4中较小的2。在默认的对界方式下，因为几乎所有的数据类型都不大于默认的对界方式8（除了long<br> double），所以所有的固有类型的对界方式可以认为就是类型自身的大小。更改一下上面的程序：</p> 
           <p align="left">#pragma pack(2)</p> 
           <p align="left">union u2</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> char<br> a[13];</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> int b;</p> 
           <p align="left">};</p> 
           <p align="left">union u3</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> char<br> a[13];</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> char b;</p> 
           <p align="left">};</p> 
           <p align="left">#pragma pack(8)</p> 
           <p align="left"> cout&lt;&lt;sizeof(u2)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 14</p> 
           <p align="left"> cout&lt;&lt;sizeof(u3)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 13</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 由于手动更改对界方式为2，所以int的对界也变成了2，u2的对界取成员中最大的对界，也是2了，所以此时sizeof(u2)=14。</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 结论：C++固有类型的对界取编译器对界方式与自身大小中较小的一个。</p> 
           <p align="left">9、struct的sizeof问题</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 因为对齐问题使结构体的sizeof变得比较复杂，看下面的例子：(默认对齐方式下)</p> 
           <p align="left">struct s1</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> char a;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> double b;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> int c;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> char d;</p> 
           <p align="left">};</p> 
           <p align="left">struct s2</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> char a;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> char b;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> int c;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> double d;</p> 
           <p align="left">};</p> 
           <p align="left"> cout&lt;&lt;sizeof(s1)&lt;&lt;endl;<br> // 24</p> 
           <p align="left"> cout&lt;&lt;sizeof(s2)&lt;&lt;endl;<br> // 16</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 同样是两个char类型，一个int类型，一个double类型，但是因为对界问题，导致他们的大小不同。计算结构体大小可以采用元素摆放法，我举例子说明一下：首先，CPU判断结构体的对界，根据上一节的结论，s1和s2的对界都取最大的元素类型，也就是double类型的对界8。然后开始摆放每个元素。</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 对于s1，首先把a放到8的对界，假定是0，此时下一个空闲的地址是1，但是下一个元素d是double类型，要放到8的对界上，离1最接近的地址是8了，所以d被放在了8，此时下一个空闲地址变成了16，下一个元素c的对界是4，16可以满足，所以c放在了16，此时下一个空闲地址变成了20，下一个元素d需要对界1，也正好落在对界上，所以d放在了20，结构体在地址21处结束。由于s1的大小需要是8的倍数，所以21-23的空间被保留，s1的大小变成了24。</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 对于s2，首先把a放到8的对界，假定是0，此时下一个空闲地址是1，下一个元素的对界也是1，所以b摆放在1，下一个空闲地址变成了2；下一个元素c的对界是4，所以取离2最近的地址4摆放c，下一个空闲地址变成了8，下一个元素d的对界是8，所以d摆放在8，所有元素摆放完毕，结构体在15处结束，占用总空间为16，正好是8的倍数。</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 这里有个陷阱，对于结构体中的结构体成员，不要认为它的对齐方式就是他的大小，看下面的例子：</p> 
           <p align="left">struct s1</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> char a[8];</p> 
           <p align="left">};</p> 
           <p align="left">struct s2</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> double d;</p> 
           <p align="left">};</p> 
           <p align="left">struct s3</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> s1 s;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> char a;</p> 
           <p align="left">};</p> 
           <p align="left">struct s4</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> s2 s;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> char a;</p> 
           <p align="left">};</p> 
           <p align="left"> cout&lt;&lt;sizeof(s1)&lt;&lt;endl;<br> // 8</p> 
           <p align="left"> cout&lt;&lt;sizeof(s2)&lt;&lt;endl;<br> // 8</p> 
           <p align="left"> cout&lt;&lt;sizeof(s3)&lt;&lt;endl;<br> // 9</p> 
           <p align="left"> cout&lt;&lt;sizeof(s4)&lt;&lt;endl;<br> // 16;</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> s1和s2大小虽然都是8，但是s1的对齐方式是1，s2是8（double），所以在s3和s4中才有这样的差异。</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 所以，在自己定义结构体的时候，如果空间紧张的话，最好考虑对齐因素来排列结构体里的元素。</p> 
           <p align="left">10、不要让double干扰你的位域</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 在结构体和类中，可以使用位域来规定某个成员所能占用的空间，所以使用位域能在一定程度上节省结构体占用的空间。不过考虑下面的代码：</p> 
           <p align="left">struct s1</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> int i: 8;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> int j: 4;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> double b;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> int a:3;</p> 
           <p align="left">};</p> 
           <p align="left">struct s2</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> int i;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> int j;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> double b;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> int a;</p> 
           <p align="left">};</p> 
           <p align="left">struct s3</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> int i;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> int j;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> int a;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> double b;</p> 
           <p align="left">};</p> 
           <p align="left">struct s4</p> 
           <p align="left">{</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> int i: 8;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> int j: 4;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> int a:3;</p> 
           <p align="left">&nbsp;<wbr>&nbsp;<wbr> double b;</p> 
           <p align="left">};</p> 
           <p align="left"> cout&lt;&lt;sizeof(s1)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 24</p> 
           <p align="left"> cout&lt;&lt;sizeof(s2)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 24</p> 
           <p align="left"> cout&lt;&lt;sizeof(s3)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 24</p> 
           <p align="left"> cout&lt;&lt;sizeof(s4)&lt;&lt;endl;&nbsp;<wbr>&nbsp;<wbr><br> // 16</p> 
           <p align="left"> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br> 可以看到，有double存在会干涉到位域（sizeof的算法参考上一节），所以使用位域的的时候，最好把float类型和double类型放在程序的开始或者最后。</p> 
           <p>&nbsp;<wbr></p> 
          </div> 
         </div> 
        </div>
       </div>
       <!-- .entry-content --> 
       <!-- .entry-meta --> 
      </article>
      <!-- #post-38 --> 
      <!-- #comments --> 
     </div>
     <!-- #content --> 
    </div>
    <!-- #primary --> 
    <!-- #secondary .widget-area --> 
   </div>
   <!-- #main --> 
   <!-- #colophon --> 
  </div>
  <!-- #page -->   
  <!-- JiaThis Button BEGIN -->  
  <!-- JiaThis Button END -->   
 </body>
</html>